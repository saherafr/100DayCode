# ğŸ“˜ LeetCode Deep Dives â€“ Pattern-Based Learning Notes

---

## ğŸ§© Problem 1: Find the Duplicate Number (Floyd's Cycle Detection)

### ğŸ” Problem Statement
Youâ€™re given an array `nums` of length `n + 1`, where each number is in the range `[1, n]`. Exactly one number is duplicated (may appear multiple times).  
Return the duplicated number.

### âœ… Brute Force Insight
- Use a `set()` to track seen values
- Return the number the moment it appears twice
- â± Time: O(n), âŒ Space: O(n)

---

### ğŸš€ Optimal Approach: Floydâ€™s Cycle Detection
Treat `nums[i]` as a pointer to index `nums[i]`. This forms a linked list where a cycle must exist due to the duplicate.

#### ğŸ” Phase 1: Detect Cycle
- Initialize: `slow = nums[0]`, `fast = nums[0]`
- Loop: `slow = nums[slow]`, `fast = nums[nums[fast]]`
- When `slow == fast` â†’ cycle detected

#### ğŸ¯ Phase 2: Find Entrance to Cycle
- Set `finder = nums[0]`
- Move both `finder = nums[finder]`, `slow = nums[slow]` until they meet
- Return the meeting point â†’ the duplicate

---

### ğŸ§  Why This Works
- Duplicate creates a cycle in the index-graph
- Detecting the start of the cycle = finding the repeated number
- â± Time: O(n)  
- ğŸ§  Space: O(1)  
- ğŸ’¯ Works for all valid inputs (e.g. `[1,1]`)

---

## ğŸ§© Problem 2: LRU Cache (System Design + Hash + List)

### ğŸ” Problem Statement
Design an LRU (Least Recently Used) Cache that:
- Returns value with `get(key)`, else `-1`
- Updates/inserts key with `put(key, value)`
- Evicts least recently used key if capacity is exceeded

Each operation must run in â± O(1) time.

---

### ğŸ”‘ Core Idea: Dict + Doubly Linked List

| Data Structure     | Role                                |
|--------------------|--------------------------------------|
| `dict`             | `key â†’ node` lookup in O(1)          |
| Doubly Linked List | Track usage order in O(1)            |
| Dummy Head/Tail    | Simplify insert/remove edge cases    |

---

### âœ¨ OrderedDict Shortcut (Python Only)
- Keeps key order by usage
- `move_to_end(key)` â†’ mark as recently used
- `popitem(last=False)` â†’ remove least recently used (front)

---

### ğŸ›  Method Summary

**`__init__(capacity)`**
- Initialize OrderedDict and store capacity

**`get(key)`**
- If key not in dict â†’ return -1
- Else:
  - Move to end (mark as most recently used)
  - Return value

**`put(key, value)`**
- If key exists:
  - Move to end and update value
- If key doesnâ€™t exist:
  - Add new key
  - If capacity exceeded â†’ pop from front

---

### ğŸ§  Key Interview Insights
- `OrderedDict` abstracts doubly linked list internally
- If implementing from scratch:
  - Use a dict and your own `Node` + doubly linked list class
- Still O(1) due to pointer rewiring and dict lookups

---

### âœ… Time & Space
- Time: O(1) for `get` and `put`
- Space: O(capacity)

---

### ğŸ”¥ Summary Quote for Interviews
> â€œI used an OrderedDict to combine hash map lookup with ordered usage tracking. `move_to_end()` and `popitem(last=False)` allow us to update and evict keys in O(1). The approach satisfies both functionality and efficiency guarantees of an LRU cache.â€

---
